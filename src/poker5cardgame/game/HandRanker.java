package poker5cardgame.game;

import java.util.HashMap;
import java.util.Map;
import poker5cardgame.game.Card.Rank;

public class HandRanker {

    // <editor-fold defaultstate="collapsed" desc="Data Definition">
    public enum HandRank {
        HIGH_CARD,
        ONE_PAIR,
        TWO_PAIR,
        THREE_OF_A_KIND,
        STRAIGHT,
        FLUSH,
        FULL_HOUSE,
        FOUR_OF_A_KIND,
        STRAIGHT_FLUSH;

        public boolean wins(HandRank other) {
            return this.compareTo(other) > 0;
        }

        public boolean ties(HandRank other) {
            return this.compareTo(other) == 0;
        }

        public boolean loses(HandRank other) {
            return this.compareTo(other) < 0;
        }
    }
    // </editor-fold>

    public static HandRank getHandRank(Hand hand) {
        int hSuitId = hand.getSuitId();
        int hWeight = hand.getWeight();
        Map hDict = hand.getDict();

        boolean straight = areSuccessive(hWeight);
        boolean flush = areSameSuit(hSuitId);
        int hDictProduct = computeDictProduct(hDict);

        switch (hDictProduct) {
            case 6:
                return HandRank.FULL_HOUSE;

            case 4:
                if (hDict.containsValue(4)) {
                    return HandRank.FOUR_OF_A_KIND;
                }
                if (!flush) {
                    return HandRank.TWO_PAIR;
                }
                return HandRank.FLUSH;

            case 3:
                if (!flush) {
                    return HandRank.THREE_OF_A_KIND;
                }
                return HandRank.FLUSH;

            case 2:
                if (!flush) {
                    return HandRank.ONE_PAIR;
                }
                return HandRank.FLUSH;

            case 1:
                if (straight) {
                    if (flush) {
                        return HandRank.STRAIGHT_FLUSH;
                    }
                    return HandRank.STRAIGHT;
                }
                if (flush) {
                    return HandRank.FLUSH;
                }
                return HandRank.HIGH_CARD;

            default:
                return null;
        }
    }

    private static boolean areSuccessive(int hWeight) {
        return Card.SUCCESSIVE_CARDS.contains(hWeight);
    }

    private static boolean areSameSuit(int hSuitId) {
        // The hand suit id has been generated by the product of the ids of each 
        // suit of the hand, so if all five cards are the same suit, the result 
        // of this product will be a number so that the fifth root is equal to an
        // integer (the suit ids are integer and prime).
        return (float) Math.pow(hSuitId, 1. / 5) % 1 == 0;
    }

    private static int computeDictProduct(Map hDict) {
        // Multiply the number of occurrences of each card rank
        int product = 1;
        for (Object value : hDict.values()) {
            product *= (int) value;
        }
        return product;
    }
        
    // TODO delete
    private static Map mergeDicts(Map hDict1, Map hDict2) {
        // mergeDict contains all the keys of hDict1 and hDict2 with the sum number of occurrences
        Map mergeDict = new HashMap(hDict1);
        mergeDict.putAll(hDict2);
        for (Object key : mergeDict.keySet()) {
            if (hDict1.containsKey(key) && hDict2.containsKey(key)) {
                mergeDict.put(key, (int) hDict1.get(key) + (int) hDict2.get(key));
            }
        }
        return mergeDict;
    }
}
